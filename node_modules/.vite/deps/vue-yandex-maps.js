import {
  computed,
  defineComponent,
  getCurrentInstance,
  h,
  inject,
  isRef,
  nextTick,
  onBeforeUnmount,
  onMounted,
  provide,
  ref,
  shallowRef,
  toRaw,
  unref,
  version,
  watch
} from "./chunk-ESTIRR4N.js";
import "./chunk-25V3TAZK.js";

// node_modules/vue-yandex-maps/dist/vue-yandex-maps.js
import "/Users/admin/Desktop/SolarCloud/vue/solarcloud/node_modules/vue-yandex-maps/dist/vue-yandex-maps.css";

// node_modules/vue-yandex-maps/dist/vue-yandex-maps-BO7vpdSl.js
var VueYandexMaps;
((VueYandexMaps2) => {
  VueYandexMaps2.settings = safeRef({
    apikey: ""
  });
  VueYandexMaps2.isReadyToInit = safeComputed(() => !!VueYandexMaps2.settings.value.apikey);
  VueYandexMaps2.ymaps = () => ymaps3;
  class YandexMapException2 extends Error {
    constructor(message) {
      super(message);
      this.message = message;
      this.name = "YandexMapException";
    }
  }
  VueYandexMaps2.YandexMapException = YandexMapException2;
  VueYandexMaps2.loadStatus = safeRef("pending");
  VueYandexMaps2.isLoaded = safeComputed(() => VueYandexMaps2.loadStatus.value === "loaded" || VueYandexMaps2.loadStatus.value === "error");
  VueYandexMaps2.loadError = safeRef(null);
})(VueYandexMaps || (VueYandexMaps = {}));
function safeRef(value) {
  if (typeof window === "undefined") {
    return {
      // @ts-ignore
      value,
      // @ts-ignore
      __v_isRef: true
    };
  }
  return ref(value);
}
function safeComputed(getter, debugOptions) {
  if (typeof window === "undefined") {
    return {
      get value() {
        return getter();
      },
      // @ts-ignore
      __v_isRef: true
    };
  }
  return computed(getter, debugOptions);
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function copy(target) {
  target = toRaw(unref(target));
  if (Array.isArray(target))
    return target.map((i) => copy(i));
  if (!target || typeof target !== "object" || (target == null ? void 0 : target.constructor) !== void 0 && (target == null ? void 0 : target.constructor) !== Object)
    return target;
  return Object.keys(target).reduce((carry, key) => {
    const val = target[key];
    carry[key] = copy(val);
    return carry;
  }, {});
}
function isDev() {
  var _a;
  return typeof process !== "undefined" && (((_a = process.env) == null ? void 0 : _a.NODE_ENV) === "development" || process.dev);
}
function getException({
  text,
  isInternal,
  warn
}) {
  if (warn) {
    text = `Warning: ${text}`;
  }
  if (isInternal) {
    text += " This is likely Vue Yandex Maps internal bug.";
    if (isDev()) {
      text += " You can report this bug here: https://github.com/yandex-maps-unofficial/vue-yandex-maps/issues/new/choose";
    }
  }
  return new VueYandexMaps.YandexMapException(text);
}
function throwException(settings) {
  const exception = getException(settings);
  if (settings.warn) {
    console.warn(exception);
  } else {
    throw exception;
  }
}
function excludeKeys(item, ignoreKeys) {
  for (const [key, value] of Object.entries(item)) {
    if (ignoreKeys.includes(key))
      delete item[key];
    if (value && typeof value === "object" && !Array.isArray(value)) {
      excludeKeys(value, ignoreKeys);
      if (!Object.keys(value).length)
        delete item[key];
    }
  }
}
function isVue2() {
  return version.startsWith("2");
}
var fragment;
async function setFragment() {
  if (fragment !== void 0)
    return;
  if (isVue2()) {
    fragment = null;
    return;
  }
  fragment = (await import("./vue.js")).Fragment;
}
function hF(children, props) {
  if (isVue2()) {
    return h("div", props, children);
  }
  return h(fragment, props, children);
}
function hVue2(children) {
  if (isVue2() && (children == null ? void 0 : children.length) > 1) {
    return h("div", children);
  }
  return children;
}
function getAttrsForVueVersion(attrs) {
  if (isVue2()) {
    return { attrs };
  }
  return attrs;
}
var YandexMapException = VueYandexMaps.YandexMapException;
var allowedOptionsKeys = {
  apikey: true,
  servicesApikeys: true,
  lang: true,
  initializeOn: true,
  importModules: true,
  version: true,
  strictMode: true,
  domain: true,
  mapsRenderWaitDuration: true,
  mapsScriptWaitDuration: true
};
function initYmaps() {
  return new Promise((res, rej) => {
    if (typeof ymaps3 !== "undefined") {
      if (VueYandexMaps.loadStatus.value !== "loaded")
        VueYandexMaps.loadStatus.value = "loaded";
      return res();
    }
    if (typeof window === "undefined")
      return rej(new YandexMapException("You must call initYmaps on Client Side only"));
    if (VueYandexMaps.loadStatus.value === "loading") {
      const watcher = watch(VueYandexMaps.loadStatus, (val) => {
        if (!VueYandexMaps.isLoaded.value)
          return;
        watcher();
        if (val === "error")
          rej(VueYandexMaps.loadError);
        if (val === "loaded")
          res();
      }, {
        immediate: true
      });
      return;
    }
    VueYandexMaps.loadStatus.value = "loading";
    const settings = VueYandexMaps.settings.value;
    if (!settings.apikey) {
      throwException({
        text: "apikey was not set for Yandex Maps initialization. Ensure you have attached needed plugins or called createYmapsOptions with apikey. If you need delayed init, please use VueYandexMaps.isReadyToInit computed as v-if."
      });
    }
    const yandexMapScript = document.createElement("SCRIPT");
    const url = new URL(`${settings.domain}/${settings.version}/`);
    url.searchParams.set("lang", settings.lang || "ru_RU");
    url.searchParams.set("apikey", settings.apikey);
    yandexMapScript.setAttribute("src", url.toString());
    yandexMapScript.setAttribute("async", "");
    yandexMapScript.setAttribute("defer", "");
    yandexMapScript.setAttribute("type", "text/javascript");
    yandexMapScript.setAttribute("id", "vue-yandex-maps");
    document.head.appendChild(yandexMapScript);
    yandexMapScript.onload = async () => {
      try {
        await VueYandexMaps.ymaps().ready;
        if (settings.servicesApikeys) {
          VueYandexMaps.ymaps().getDefaultConfig().setApikeys(settings.servicesApikeys);
        }
        if (typeof settings.strictMode === "boolean")
          VueYandexMaps.ymaps().strictMode = settings.strictMode;
        if (settings.importModules) {
          await Promise.all(
            settings.importModules.map(
              (module) => VueYandexMaps.ymaps().import(module)
            )
          );
        }
        VueYandexMaps.loadStatus.value = "loaded";
        res();
      } catch (e) {
        VueYandexMaps.loadStatus.value = "error";
        VueYandexMaps.loadError.value = e;
        rej(e);
      }
    };
    yandexMapScript.onerror = (e) => {
      VueYandexMaps.loadError.value = e;
      rej(e);
    };
  });
}
function createYmapsOptions(options, ignoreNoCurrentInstance = false) {
  if (VueYandexMaps.isReadyToInit.value)
    return VueYandexMaps.settings.value;
  const optionsShallowClone = {
    lang: "ru_RU",
    initializeOn: "onComponentMount",
    importModules: [],
    version: "v3",
    strictMode: false,
    domain: "https://api-maps.yandex.ru",
    mapsRenderWaitDuration: true,
    mapsScriptWaitDuration: true,
    servicesApikeys: {},
    ...options
  };
  if (!optionsShallowClone.apikey) {
    throwException({
      text: "You must specify apikey for createYmapsOptions"
    });
  }
  const notAllowedKeys = Object.keys(optionsShallowClone).filter((key) => !(key in allowedOptionsKeys));
  if (notAllowedKeys.length) {
    throwException({
      text: `You have passed unknown keys to createYmapsOptions: ${notAllowedKeys.join(", ")}. Only ${Object.keys(allowedOptionsKeys).join(", ")} are allowed.`
    });
  }
  if (typeof window === "undefined")
    return optionsShallowClone;
  VueYandexMaps.settings.value = optionsShallowClone;
  return optionsShallowClone;
}

// node_modules/vue-yandex-maps/dist/vue-yandex-maps.js
function applyModifier(coords, modifier) {
  const result = {
    x: 0,
    y: 0
  };
  result.x = coords.x * modifier;
  result.y = coords.y * modifier;
  return result;
}
function applyFunctionModifier(coords, functionModifier) {
  const result = {
    x: 0,
    y: 0
  };
  result.x = functionModifier(coords.x, 1);
  result.y = functionModifier(coords.y, 2);
  return result;
}
function worldToPixels(coords, modifier) {
  const i = 2 ** modifier / 2 * 256;
  return applyModifier({
    x: coords.x + 1,
    y: 1 - coords.y
  }, i);
}
function convertWorldCoordinates(projection, coordinates, modifier) {
  const worldCoordinates = projection.toWorldCoordinates(coordinates);
  return worldToPixels(worldCoordinates, modifier);
}
function pixelsToWorld(coords, modifier) {
  const i = 2 ** modifier / 2 * 256;
  return {
    x: coords.x / i - 1,
    y: 1 - coords.y / i
  };
}
function findNeededValue(t, e, i) {
  return Math.max(Math.min(t, i), e);
}
function worldCoordsFromModifier(projection, coords, modifier) {
  const resultCoords = applyFunctionModifier(pixelsToWorld(coords, modifier), (value) => findNeededValue(value, -1, 1 - 1e-15));
  return projection.fromWorldCoordinates(resultCoords);
}
function convertBounds(projection, bounds, modifier) {
  const topLeft = convertWorldCoordinates(projection, bounds[0], modifier);
  const bottomRight = convertWorldCoordinates(projection, bounds[1], modifier);
  const modified = 2 ** modifier * 256;
  const updatedBounds = [[topLeft.x, topLeft.y], [bottomRight.x, bottomRight.y]];
  if (topLeft.x > bottomRight.x) {
    updatedBounds[0][0] = topLeft.x;
    updatedBounds[1][0] = bottomRight.x + modified;
  }
  if (topLeft.y > bottomRight.y) {
    updatedBounds[0][1] = bottomRight.y;
    updatedBounds[1][1] = topLeft.y;
  }
  return updatedBounds;
}
function applyMarginToCoords(coords, margin) {
  return {
    x: Math.max(coords.x - (margin ? margin[1] + margin[3] : 0), 1),
    y: Math.max(coords.y - (margin ? margin[0] + margin[2] : 0), 1)
  };
}
function findZoom(projection, bounds, coords, isSnap, zoomRange) {
  const [[topLeftFirst, topLeftSecond], [bottomRightFirst, bottomRightSecond]] = convertBounds(projection, bounds, 0);
  const firstCalc = Math.max(Math.abs(bottomRightFirst - topLeftFirst), 1e-10);
  const secondCalc = Math.max(Math.abs(bottomRightSecond - topLeftSecond), 1e-10);
  const zoom = findNeededValue(Math.min(Math.log2(coords.x / firstCalc), Math.log2(coords.y / secondCalc)), zoomRange.min, zoomRange.max);
  return isSnap ? Math.floor(zoom + 1e-6) : zoom;
}
function findCenter(projection, bounds, zoom) {
  const [[topLeftFirst, topLeftSecond], [bottomRightFirst, bottomRightSecond]] = convertBounds(projection, bounds, zoom);
  return worldCoordsFromModifier(projection, {
    x: (topLeftFirst + bottomRightFirst) / 2,
    y: (topLeftSecond + bottomRightSecond) / 2
  }, zoom);
}
async function getLocationFromBounds({
  bounds,
  map,
  roundZoom,
  comfortZoomLevel
}) {
  var _a;
  const ctxMap = Object.keys(map).find((x) => x.endsWith("CtxMap"));
  if (!ctxMap) {
    throwException({
      text: "CtxMap was not found in useYMapsGetCenterAndZoomFromBounds",
      isInternal: true
    });
  }
  const ctx = map[ctxMap];
  const ctxItem = await new Promise((resolve, reject) => {
    ctx.forEach((item, { name }) => {
      if (name !== "map")
        return;
      resolve(item);
    });
    reject(getException({
      text: "Map item was not found in useYMapsGetCenterAndZoomFromBounds",
      isInternal: true
    }));
  });
  const ctxItemMapKey = Object.keys(ctxItem).find((x) => x.endsWith("_context"));
  if (!ctxItemMapKey) {
    throwException({
      text: "CtxMapKey was not found in useYMapsGetCenterAndZoomFromBounds",
      isInternal: true
    });
  }
  const ctxItemMap = ctxItem[ctxItemMapKey].map;
  const boundsFunc = ctxItemMap.setBounds.toString();
  const funcKey = (_a = boundsFunc.split("const{center:e,zoom:i}=")[1]) == null ? void 0 : _a.split("(")[0];
  if (!funcKey) {
    throwException({
      text: "funcKey was not found in useYMapsGetCenterAndZoomFromBounds",
      isInternal: true
    });
  }
  const projection = ctxItemMap.projection;
  const size = ctxItemMap.size;
  const margin = ctxItemMap.margin;
  const isSnap = ctxItemMap.effectiveZoomRounding === "snap";
  const zoomRange = ctxItemMap.zoomRange;
  let zoom = findZoom(projection, bounds, applyMarginToCoords(size, margin), isSnap, zoomRange);
  const center = findCenter(projection, bounds, zoom);
  if (roundZoom || comfortZoomLevel) {
    const originalZoom = zoom;
    let roundedZoom = Math[typeof roundZoom === "string" ? roundZoom : "floor"](zoom);
    if (roundZoom)
      zoom = roundedZoom;
    if (comfortZoomLevel) {
      const userSettings = typeof comfortZoomLevel === "object" ? comfortZoomLevel : {};
      if (userSettings.roundStrategy)
        roundedZoom = Math[userSettings.roundStrategy](originalZoom);
      const diff2 = originalZoom - roundedZoom;
      const settings = {
        diff: 0.5,
        correction: 1,
        ...userSettings
      };
      if (diff2 < settings.diff) {
        zoom -= settings.correction;
      }
    }
  }
  return {
    zoom,
    center
  };
}
var useYMapsLocationFromBounds = getLocationFromBounds;
function getCenterFromCoords(coordinates) {
  if (coordinates.length === 1)
    return coordinates[0];
  if (!coordinates.length) {
    throwException({
      text: "Invalid parameters in useYMapsCenterFromCoords: you must pass at least one LngLat"
    });
  }
  const sum = coordinates.reduce(([accLng, accLat], [lng, lat]) => [
    accLng + lng,
    accLat + lat
  ], [0, 0]);
  return [
    sum[0] / coordinates.length,
    sum[1] / coordinates.length
  ];
}
function getBoundsFromCoords(coordinates) {
  if (coordinates.length < 2) {
    throwException({
      text: "Invalid parameters in useYMapsBoundsFromCoords: you must pass at least two LngLat"
    });
  }
  const {
    minLongitude,
    minLatitude,
    maxLongitude,
    maxLatitude
  } = coordinates.reduce(
    (acc, [longitude, latitude]) => ({
      minLongitude: Math.min(acc.minLongitude, longitude),
      minLatitude: Math.min(acc.minLatitude, latitude),
      maxLongitude: Math.max(acc.maxLongitude, longitude),
      maxLatitude: Math.max(acc.maxLatitude, latitude)
    }),
    {
      minLongitude: Infinity,
      minLatitude: Infinity,
      maxLongitude: -Infinity,
      maxLatitude: -Infinity
    }
  );
  return [[minLongitude, maxLatitude], [maxLongitude, minLatitude]];
}
function createYmaps(settings) {
  return {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    install(app) {
      createYmapsOptions(settings);
      if (settings.initializeOn === "onPluginInit") {
        initYmaps().catch(console.error);
      }
    }
  };
}
function createYmapsVue2(settings) {
  return {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    install(Vue) {
      createYmapsOptions(settings);
      if (settings.initializeOn === "onPluginInit") {
        initYmaps().catch(console.error);
      }
    }
  };
}
var isDate = (d) => d instanceof Date;
var isEmpty = (o) => Object.keys(o).length === 0;
var isObject = (o) => o != null && typeof o === "object";
var hasOwnProperty = (o, ...args) => Object.prototype.hasOwnProperty.call(o, ...args);
var isEmptyObject = (o) => isObject(o) && isEmpty(o);
var makeObjectWithoutPrototype = () => /* @__PURE__ */ Object.create(null);
var diff = (lhs, rhs) => {
  if (lhs === rhs)
    return {};
  if (!isObject(lhs) || !isObject(rhs))
    return rhs;
  const deletedValues = Object.keys(lhs).reduce((acc, key) => {
    if (!hasOwnProperty(rhs, key)) {
      acc[key] = void 0;
    }
    return acc;
  }, makeObjectWithoutPrototype());
  if (isDate(lhs) || isDate(rhs)) {
    if (lhs.valueOf() == rhs.valueOf())
      return {};
    return rhs;
  }
  return Object.keys(rhs).reduce((acc, key) => {
    if (!hasOwnProperty(lhs, key)) {
      acc[key] = rhs[key];
      return acc;
    }
    const difference = diff(lhs[key], rhs[key]);
    if (isEmptyObject(difference) && !isDate(difference) && (isEmptyObject(lhs[key]) || !isEmptyObject(rhs[key])))
      return acc;
    acc[key] = difference;
    return acc;
  }, deletedValues);
};
function injectMap() {
  if (!getCurrentInstance()) {
    throwException({
      text: "injectMap must be only called on runtime.",
      isInternal: true
    });
  }
  const map = inject("map");
  if (!map || !isRef(map)) {
    throwException({
      text: "Was not able to inject valid map in injectMap.",
      isInternal: true
    });
  }
  return map;
}
function injectLayers() {
  if (!getCurrentInstance()) {
    throwException({
      text: "injectLayers must be only called on runtime.",
      isInternal: true
    });
  }
  const layers = inject("layers");
  if (!layers || !isRef(layers)) {
    throwException({
      text: "Was not able to inject valid layers in injectLayers.",
      isInternal: true
    });
  }
  return layers;
}
async function waitTillYmapInit({
  timeoutCallback,
  waitDuration
} = {}) {
  if (typeof window === "undefined") {
    throwException({
      text: "waitTillYmapInit cannot be called on SSR.",
      isInternal: true
    });
  }
  if (typeof ymaps3 !== "undefined")
    return;
  return new Promise((resolve, reject) => {
    if (typeof ymaps3 === "undefined") {
      let timeout;
      waitDuration = typeof waitDuration !== "undefined" ? waitDuration : VueYandexMaps.settings.value.mapsScriptWaitDuration;
      if (waitDuration !== false) {
        timeout = setTimeout(() => {
          timeoutCallback == null ? void 0 : timeoutCallback(timeout, true);
          reject(new VueYandexMaps.YandexMapException("Was not able to wait for map initialization in waitTillYmapInit. Ensure that map was initialized. You can change this behavior by using mapsScriptWaitDuration."));
        }, typeof waitDuration === "number" ? waitDuration : 5e3);
        timeoutCallback == null ? void 0 : timeoutCallback(timeout, false);
      }
      watch(VueYandexMaps.isLoaded, () => {
        if (timeout) {
          clearTimeout(timeout);
          timeoutCallback == null ? void 0 : timeoutCallback(timeout, true);
        }
        if (VueYandexMaps.loadStatus.value === "loaded") {
          resolve();
        } else {
          reject(VueYandexMaps.loadError);
        }
      }, {
        immediate: true
      });
    } else {
      resolve();
    }
  });
}
async function waitTillMapInit({
  map: _map,
  timeoutCallback,
  waitDuration
} = {}) {
  if (!_map && !getCurrentInstance()) {
    throwException({
      text: "onMapInit must be only called on runtime.",
      isInternal: true
    });
  }
  if (typeof window === "undefined") {
    throwException({
      text: "waitTillMapInit cannot be called on SSR.",
      isInternal: true
    });
  }
  const map = _map || injectMap();
  if (map.value)
    return;
  return new Promise((resolve, reject) => {
    let timeout;
    waitDuration = typeof waitDuration !== "undefined" ? waitDuration : VueYandexMaps.settings.value.mapsRenderWaitDuration;
    if (waitDuration !== false) {
      timeout = setTimeout(() => {
        timeoutCallback == null ? void 0 : timeoutCallback(timeout, true);
        reject(new VueYandexMaps.YandexMapException("Was not able to wait for map initialization in waitTillMapInit. You can change this behavior by using mapsRenderWaitDuration."));
      }, typeof waitDuration === "number" ? waitDuration : 5e3);
      timeoutCallback == null ? void 0 : timeoutCallback(timeout, false);
    }
    let watcher;
    watcher = watch(map, () => {
      if (map.value) {
        watcher == null ? void 0 : watcher();
        if (timeout) {
          clearTimeout(timeout);
          timeoutCallback == null ? void 0 : timeoutCallback(timeout, true);
        }
        resolve();
      }
    }, {
      immediate: true
    });
  });
}
function deleteMapChild({
  children,
  isMercator,
  root
}) {
  var _a;
  if (!root) {
    throwException({
      text: "Failed to execute deleteMapChild due to destroyed root",
      isInternal: true
    });
  }
  if (children && !isMercator) {
    if (typeof (root == null ? void 0 : root.value) === "object" && Array.isArray(root.value)) {
      root.value = root.value.filter((x) => x !== children);
    } else {
      (_a = root.value) == null ? void 0 : _a.removeChild(children);
    }
  } else if (root.value && children && isMercator && "update" in root.value) {
    root.value.update({
      projection: void 0
    });
  }
}
var _sfc_main$o = defineComponent({
  name: "YandexMap",
  props: {
    modelValue: {
      type: Object,
      default: null
    },
    value: {
      type: Object,
      default: null
    },
    tag: {
      type: String,
      default: "div"
    },
    width: {
      type: String,
      default: "100%"
    },
    height: {
      type: String,
      default: "100%"
    },
    // z-index for Map Container. Without this, elements of the map will be displayed under your site's elements due to high z-index inside of them
    zIndex: {
      type: Number,
      default: 0
    },
    /**
     * @description Settings for cart initialization.,
     *
     * You can modify this object or use map methods, such as setLocation/setBehaviors e.t.c.
     * @see https://yandex.ru/dev/maps/jsapi/doc/3.0/dg/concepts/map.html#map-parms
     * @see https://yandex.com/dev/maps/jsapi/doc/3.0/dg/concepts/map.html#map-parms
     */
    settings: {
      type: Object,
      required: true
    },
    /**
     * @description Makes settings readonly. Enable this if reactivity causes problems
     */
    readonlySettings: {
      type: Boolean,
      default: false
    },
    /**
     * @description Always inserts actual user center or bounds (based on your input) on every location change
     * @note This prop will cause user location change on every settings update (if user did move since last time). Use it with caution.
     */
    realSettingsLocation: {
      type: Boolean,
      default: false
    },
    /**
     * @description You can also add layers through <yandex-*> components
     *
     * Modifying this object after mount will cause no effect.
     *
     * Instead, please use map methods, such as addChild.
     * @see https://yandex.ru/dev/maps/jsapi/doc/3.0/dg/concepts/map.html#layers
     * @see https://yandex.com/dev/maps/jsapi/doc/3.0/dg/concepts/map.html#layers
     */
    layers: {
      type: Array,
      default: () => []
    },
    /**
     * @description Adds cursor: grab/grabbing to ymaps scheme layer
     */
    cursorGrab: {
      type: Boolean,
      default: false
    }
  },
  /**
   * @description Other events are NOT available. You can listen to events via layers prop, addChildren prop or by adding <ymap-listener> as children.
   * @see https://yandex.ru/dev/maps/jsapi/doc/3.0/dg/concepts/events.html
   * @see https://yandex.com/dev/maps/jsapi/doc/3.0/dg/concepts/events.html
   */
  emits: {
    "input"(map) {
      return !map || typeof ymaps3 === "undefined" || map instanceof ymaps3.YMap;
    },
    "update:modelValue"(map) {
      return !map || typeof ymaps3 === "undefined" || map instanceof ymaps3.YMap;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const map = shallowRef(null);
    const mapRef = shallowRef(null);
    const layers = shallowRef([]);
    const projection = shallowRef(null);
    const ymapContainer = shallowRef(null);
    const mounted = shallowRef(false);
    const needsToHold = ref(0);
    provide("map", map);
    provide("layers", layers);
    provide("projection", projection);
    provide("needsToHold", needsToHold);
    emit("input", map.value);
    emit("update:modelValue", map.value);
    const getSettings = computed(() => ({
      ...props.settings,
      projection: void 0
    }));
    const init = async () => {
      if (!props.settings.location) {
        throwException({
          text: "You must specify location in YandexMap settings"
        });
      }
      if (map.value)
        map.value.destroy();
      const container = ymapContainer.value;
      if (!container)
        return;
      const settings = getSettings.value;
      if (projection.value)
        settings.projection = projection.value;
      map.value = new ymaps3.YMap(container, settings, [
        ...layers.value,
        ...props.layers
      ]);
      emit("input", map.value);
      emit("update:modelValue", map.value);
    };
    onMounted(async () => {
      let listener;
      let watcher;
      let cursorGrabTimeout = null;
      onBeforeUnmount(() => {
        if (cursorGrabTimeout)
          clearTimeout(cursorGrabTimeout);
      });
      const setupWatcher = () => {
        watcher == null ? void 0 : watcher();
        let settings = copy(getSettings);
        watcher = watch(getSettings, (val) => {
          var _a;
          if (!map.value)
            return;
          const clonedSettings = copy(val);
          if (props.realSettingsLocation && clonedSettings.location) {
            if ("center" in clonedSettings.location && "center" in settings.location) {
              settings.location.center = map.value.center;
            } else if ("bounds" in clonedSettings.location && "bounds" in settings.location) {
              settings.location.bounds = map.value.bounds;
            }
            if ("zoom" in clonedSettings.location && "zoom" in settings.location)
              settings.location.zoom = map.value.zoom;
          }
          const settingsDiff = Object.keys(diff(settings, clonedSettings));
          if (settingsDiff.length === 0)
            return;
          const updatedSettings = { ...clonedSettings };
          for (const key in updatedSettings) {
            if (!settingsDiff.includes(key))
              delete updatedSettings[key];
          }
          settings = clonedSettings;
          (_a = map.value) == null ? void 0 : _a.update(updatedSettings);
        }, {
          deep: true
        });
      };
      if (!props.readonlySettings) {
        setupWatcher();
      }
      watch(() => props.readonlySettings, (val) => {
        if (!val) {
          watcher == null ? void 0 : watcher();
        } else {
          setupWatcher();
        }
      });
      watch(() => props.cursorGrab, async (val) => {
        await waitTillMapInit({
          map,
          timeoutCallback: (_timeout, isDelete) => {
            if (isDelete) {
              cursorGrabTimeout = null;
            } else {
              cursorGrabTimeout = _timeout;
            }
          }
        }).catch(() => {
        });
        if (!map.value)
          return;
        if (val) {
          listener = new ymaps3.YMapListener({
            onActionStart: (e) => {
              var _a;
              if (e.type === "drag" && props.cursorGrab)
                (_a = mapRef.value) == null ? void 0 : _a.classList.add("__ymap--grabbing");
            },
            onActionEnd: (e) => {
              var _a;
              if (e.type === "drag")
                (_a = mapRef.value) == null ? void 0 : _a.classList.remove("__ymap--grabbing");
            }
          });
          map.value.addChild(listener);
        } else if (listener)
          map.value.removeChild(listener);
      }, { immediate: true });
      const eventListener = (event) => {
        var _a;
        const target = event.target;
        if (!target || !("classList" in target))
          return;
        if (target.classList.contains("ymaps3x0--button") || ((_a = target.closest) == null ? void 0 : _a.call(target, ".ymaps3x0--button")))
          event.preventDefault();
      };
      watch(ymapContainer, (container) => {
        if (!container)
          return;
        container.removeEventListener("click", eventListener, { capture: true });
        container.addEventListener("click", eventListener, { capture: true });
      }, {
        immediate: true
      });
      await setFragment();
      if (!VueYandexMaps.isLoaded.value) {
        if (VueYandexMaps.settings.value.initializeOn === "onComponentMount") {
          try {
            await initYmaps();
          } catch (e) {
            console.error("An error occured while initializing Yandex Map with onComponentMount setting");
            console.error(e);
            return;
          }
        } else if (VueYandexMaps.loadStatus.value === "loading" || VueYandexMaps.settings.value.initializeOn === "onPluginInit") {
          if (VueYandexMaps.settings.value.initializeOn === "onPluginInit" && VueYandexMaps.loadStatus.value !== "loading")
            await nextTick();
          await initYmaps();
        }
        if (!VueYandexMaps.isLoaded.value) {
          throwException({
            text: "You have set up <yandex-map> component without initializing Yandex maps. Please check initializeOn setting or call initYmaps manually before registering this component."
          });
        }
      }
      mounted.value = true;
      await nextTick();
      if (needsToHold.value) {
        await new Promise((resolve) => watch(needsToHold, () => {
          if (!needsToHold.value)
            resolve();
        }, {
          immediate: true
        }));
      }
      await init();
    });
    onBeforeUnmount(() => {
      map.value = null;
      emit("input", map.value);
      emit("update:modelValue", map.value);
    });
    return () => {
      var _a;
      const mapNodeProps = {
        class: [
          "__ymap",
          {
            "__ymap--grab": props.cursorGrab
          }
        ],
        ref: mapRef,
        style: {
          width: props.width,
          height: props.height,
          "z-index": props.zIndex.toString()
        }
      };
      const containerNode = h("div", {
        class: "__ymap_container",
        ref: ymapContainer
      });
      const slotsNodeProps = {
        class: "__ymap_slots",
        style: { display: "none" }
      };
      if (!mounted.value)
        return h(props.tag, mapNodeProps, [containerNode, h("div", slotsNodeProps)]);
      return h(props.tag, mapNodeProps, [
        containerNode,
        h("div", slotsNodeProps, (_a = slots.default) == null ? void 0 : _a.call(slots, {}))
      ]);
    };
  }
});
async function setupMapChildren({
  returnOnly,
  willDeleteByHand,
  strictMapRoot,
  requiredImport,
  createFunction,
  settings,
  settingsUpdateIgnoreKeys,
  isLayer,
  isMercator,
  isMapRoot,
  mapRootRef,
  duplicateInit
}) {
  if (!getCurrentInstance()) {
    throwException({
      text: "setupMapChildren must be only called on runtime.",
      isInternal: true
    });
  }
  const children = shallowRef();
  const mapRoot = inject("mapRoot", null);
  const initPromises = inject("mapRootInitPromises", null);
  let childrenPromises;
  const map = injectMap();
  const layers = injectLayers();
  let timeouts = null;
  const timeoutCallback = (timeout, isDelete) => {
    if (!timeouts)
      timeouts = /* @__PURE__ */ new Set();
    if (!isDelete)
      timeouts.add(timeout);
    else
      timeouts.delete(timeout);
  };
  if (isMapRoot && !duplicateInit) {
    provide("mapRoot", mapRootRef || children);
    childrenPromises = shallowRef([]);
    provide("mapRootInitPromises", childrenPromises);
  }
  if (!returnOnly && !willDeleteByHand) {
    onBeforeUnmount(() => {
      if (children.value) {
        deleteMapChild({
          children: children.value,
          isMercator,
          root: (mapRoot == null ? void 0 : mapRoot.value) ? mapRoot : map
        });
      }
      if (timeouts == null ? void 0 : timeouts.size) {
        timeouts.forEach((timeout) => clearTimeout(timeout));
        timeouts.clear();
      }
    });
  }
  if (settings) {
    let lastSettings = copy(settings);
    watch(settings, (value) => {
      if (!value)
        return;
      const settingsDiff = Object.keys(diff(lastSettings, value));
      if (settingsDiff.length === 0)
        return;
      const updatedSettings = copy(value);
      for (const key in updatedSettings) {
        if (!settingsDiff.includes(key))
          delete updatedSettings[key];
      }
      const ignoreKeys = settingsUpdateIgnoreKeys && (isRef(settingsUpdateIgnoreKeys) ? settingsUpdateIgnoreKeys.value : settingsUpdateIgnoreKeys);
      if (ignoreKeys)
        excludeKeys(updatedSettings, ignoreKeys);
      if (Object.keys(updatedSettings).length === 0)
        return;
      lastSettings = copy(value);
      if (children.value && "update" in children.value)
        children.value.update(updatedSettings);
    }, { deep: true });
  }
  if (!isLayer && !isMercator) {
    await waitTillMapInit({ timeoutCallback });
    if (!map.value) {
      throwException({
        text: "map is undefined in setupMapChildren. Please verify that Yandex Maps were initialized successfully and you only use components inside <yandex-map>."
      });
    }
  } else {
    await waitTillYmapInit({ timeoutCallback });
  }
  if (strictMapRoot) {
    if (!(mapRoot == null ? void 0 : mapRoot.value))
      await nextTick();
    if (!(mapRoot == null ? void 0 : mapRoot.value)) {
      throwException({
        text: `mapRoot is undefined in setupMapChildren. Please verify that you are using component inside it's root: for example, don't use Controls outside <yandex-map-controls>.`
      });
    }
  }
  if (isMapRoot) {
    await nextTick();
    await Promise.all((childrenPromises == null ? void 0 : childrenPromises.value) || []);
  }
  let importData;
  if (requiredImport) {
    const importPromise = requiredImport();
    if (initPromises == null ? void 0 : initPromises.value)
      initPromises.value.push(Promise.resolve(importPromise));
    importData = await importPromise;
  }
  children.value = createFunction(importData);
  if (!returnOnly && map.value && !isMercator) {
    if (initPromises == null ? void 0 : initPromises.value) {
      await Promise.all(initPromises.value);
      if (!requiredImport)
        await nextTick();
    }
    if (typeof (mapRoot == null ? void 0 : mapRoot.value) === "object" && Array.isArray(mapRoot.value)) {
      mapRoot.value = [
        ...mapRoot.value,
        children.value
      ];
    } else {
      ((mapRoot == null ? void 0 : mapRoot.value) || map.value).addChild(children.value);
    }
  } else if (isLayer) {
    layers.value.push(children.value);
  } else if (isMercator && map.value) {
    map.value.update({
      projection: children.value
    });
  }
  return children.value;
}
var _sfc_main$n = defineComponent({
  name: "YandexMapListener",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    let mapListener;
    onMounted(async () => {
      mapListener = await setupMapChildren({
        createFunction: () => new ymaps3.YMapListener(props.settings || {}),
        settings: computed(() => props.settings)
      });
      emit("input", mapListener);
      emit("update:modelValue", mapListener);
    });
    return () => {
      var _a;
      return hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
var _sfc_main$m = defineComponent({
  name: "YandexMapDefaultFeaturesLayer",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    },
    hold(status) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const hold = inject("needsToHold");
    hold.value++;
    let mapLayer;
    onMounted(async () => {
      mapLayer = await setupMapChildren({
        createFunction: () => new ymaps3.YMapDefaultFeaturesLayer(props.settings || {}),
        settings: computed(() => props.settings),
        isLayer: true
      });
      emit("input", mapLayer);
      emit("update:modelValue", mapLayer);
      hold.value--;
    });
    return () => {
      var _a;
      return hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
var _sfc_main$l = defineComponent({
  name: "YandexMapDefaultSchemeLayer",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  slots: Object,
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    },
    hold(status) {
      return true;
    }
  },
  setup(props, {
    slots,
    emit
  }) {
    const hold = inject("needsToHold");
    hold.value++;
    let mapLayer;
    onMounted(async () => {
      mapLayer = await setupMapChildren({
        createFunction: () => new ymaps3.YMapDefaultSchemeLayer(props.settings || {}),
        settings: computed(() => props.settings),
        isLayer: true
      });
      emit("input", mapLayer);
      emit("update:modelValue", mapLayer);
      hold.value--;
    });
    return () => {
      var _a;
      return (_a = slots.default) == null ? void 0 : _a.call(slots, {});
    };
  }
});
var _sfc_main$k = defineComponent({
  name: "YandexMapDefaultSatelliteLayer",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    },
    hold(status) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const hold = inject("needsToHold");
    hold.value++;
    let mapLayer;
    onMounted(async () => {
      mapLayer = await setupMapChildren({
        createFunction: () => new ymaps3.YMapDefaultSatelliteLayer(props.settings || {}),
        settings: computed(() => props.settings),
        isLayer: true
      });
      emit("input", mapLayer);
      emit("update:modelValue", mapLayer);
      hold.value--;
    });
    return () => {
      var _a;
      return hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
var _sfc_main$j = defineComponent({
  name: "YandexMapTileDataSource",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      required: true
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    },
    hold(status) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const hold = inject("needsToHold");
    hold.value++;
    let mapChildren;
    onMounted(async () => {
      if (!props.settings.id) {
        throwException({
          text: "You must specify id in YandexMapTileDataSource settings"
        });
      }
      mapChildren = await setupMapChildren({
        createFunction: () => new ymaps3.YMapTileDataSource(props.settings),
        settings: computed(() => props.settings),
        isLayer: true
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
      hold.value--;
    });
    return () => {
      var _a;
      return hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
var _sfc_main$i = defineComponent({
  name: "YandexMapFeatureDataSource",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      required: true
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    },
    hold(status) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const hold = inject("needsToHold");
    hold.value++;
    let mapChildren;
    onMounted(async () => {
      if (!props.settings.id) {
        throwException({
          text: "You must specify id in YandexMapFeatureDataSource settings"
        });
      }
      mapChildren = await setupMapChildren({
        createFunction: () => new ymaps3.YMapFeatureDataSource(props.settings),
        settings: computed(() => props.settings),
        isLayer: true
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
      hold.value--;
    });
    return () => {
      var _a;
      return hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
var _sfc_main$h = defineComponent({
  name: "YandexMapLayer",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      required: true
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    },
    hold(status) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const hold = inject("needsToHold");
    hold.value++;
    let mapLayer;
    onMounted(async () => {
      if (!props.settings.type) {
        throwException({
          text: "You must specify type in YandexMapLayer settings"
        });
      }
      mapLayer = await setupMapChildren({
        createFunction: () => new ymaps3.YMapLayer(props.settings || {}),
        settings: computed(() => props.settings),
        isLayer: true
      });
      emit("input", mapLayer);
      emit("update:modelValue", mapLayer);
      hold.value--;
    });
    return () => {
      var _a;
      return hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
function getMarkerContainerProps({
  position,
  containerAttrs,
  wrapperAttrs,
  zeroSizes
}) {
  const root = {
    class: ["__ymap-marker"],
    style: {}
  };
  const children = {
    class: ["__ymap-marker_wrapper"],
    style: {}
  };
  const isDefaultPosition = position === "default" || position === "default default";
  if (position && !isDefaultPosition) {
    if (position.startsWith("translate")) {
      children.style.transform = position;
    } else {
      let translateX = 0;
      let translateY = 0;
      const splitted = position.split(" ");
      for (let i = 0; i < splitted.length; i++) {
        let local = 0;
        const item = splitted[i];
        switch (item) {
          case "top":
          case "left":
            local = -100;
            break;
          case "top-center":
          case "left-center":
            local = -50;
            break;
          case "bottom":
          case "right":
            local = 100;
            break;
          case "bottom-center":
          case "right-center":
            local = 50;
            break;
          default:
            local = 0;
        }
        if (item.startsWith("left") || item.startsWith("right"))
          translateX = local;
        else
          translateY = local;
      }
      children.style.transform = `translate(${translateX}%, ${translateY}%)`;
    }
  }
  if (zeroSizes === true || zeroSizes !== false && position && !isDefaultPosition) {
    root.style.width = "0";
    root.style.height = "0";
    if (children.style.transform)
      children.style.width = "fit-content";
  }
  const attrs = {
    root: { ...containerAttrs ?? {} },
    children: { ...wrapperAttrs ?? {} }
  };
  for (const [key, value] of Object.entries(attrs)) {
    const obj = key === "root" ? root : children;
    if (value.class) {
      if (!Array.isArray(value.class))
        value.class = [value.class];
      value.class = [
        ...obj.class,
        ...value.class
      ];
    }
    if (value == null ? void 0 : value.style) {
      if (typeof value.style !== "object" || Array.isArray(value.style)) {
        console.warn(`Style property was given in ${key} of marker, but it is not an object. Style of this prop can only be an object, therefore it was ignored.`);
      } else {
        value.style = {
          ...obj.style,
          ...value.style
        };
      }
    }
    Object.assign(obj, value);
  }
  return {
    root,
    children
  };
}
function excludeYandexMarkerProps(props) {
  props = { ...props };
  const toExclude = {
    position: true,
    containerAttrs: true,
    wrapperAttrs: true,
    zeroSizes: true
  };
  for (const excluded in toExclude) {
    if (excluded in props)
      delete props[excluded];
  }
  return props;
}
var _sfc_main$g = defineComponent({
  name: "YandexMapMarker",
  inheritAttrs: false,
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      required: true
    },
    /**
     * @description Sets translate(%, %) to marker to align it properly.
     *
     * If you want to make aligment to be like Yandex Maps 2.0, set this property to "top left-center".
     * @default default (as goes in Yandex by default)
     */
    position: {
      type: String
    },
    /**
     * @description Allows you to add any attributes to <div class="__ymap-marker"> container.
     *
     * Important: to pass styles, you must use object-style prop instead of string.
     */
    containerAttrs: {
      type: Object,
      default: () => ({})
    },
    /**
     * @description Allows you to add any attributes to <div class="__ymap-marker_wrapper"> container.
     *
     * Important: to pass styles, you must use object-style prop instead of string.
     */
    wrapperAttrs: {
      type: Object,
      default: () => ({})
    },
    /**
     * @description Will add width and height: 0 to container.
     *
     * Null enables default behavior, false disables it completely (even if position is specified).
     *
     * @default true if position is specified, false otherwise
     */
    zeroSizes: {
      type: Boolean,
      default: null
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit,
    attrs
  }) {
    let mapChildren;
    const element = ref(null);
    onMounted(async () => {
      if (!props.settings.coordinates) {
        throwException({
          text: "You must specify coordinates in YandexMapMarker settings"
        });
      }
      mapChildren = await setupMapChildren({
        settings: computed(() => props.settings),
        createFunction: () => new ymaps3.YMapMarker(props.settings, element.value)
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    watch(element, () => {
      var _a;
      if (element.value)
        (_a = element.value.parentNode) == null ? void 0 : _a.removeChild(element.value);
    });
    const rootProps = computed(() => getMarkerContainerProps({
      position: props.position,
      containerAttrs: props.containerAttrs,
      wrapperAttrs: props.wrapperAttrs,
      zeroSizes: props.zeroSizes
    }));
    return () => {
      var _a;
      return hF([
        h("div", {
          ...rootProps.value.root,
          ref: element,
          ...getAttrsForVueVersion(attrs)
        }, [
          h("div", {
            ...rootProps.value.children
          }, (_a = slots.default) == null ? void 0 : _a.call(slots, {}))
        ])
      ]);
    };
  }
});
var _sfc_main$f = defineComponent({
  name: "YandexMapDefaultMarker",
  inheritAttrs: false,
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      required: true
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit,
    attrs
  }) {
    let mapChildren;
    const popup = ref(null);
    const closeFunc = ref(() => {
    });
    const contentFunc = (close) => {
      closeFunc.value = close;
      return popup.value;
    };
    const getSettings = computed(() => {
      const settings = { ...props.settings };
      if (settings.popup && (typeof settings.popup.content === "undefined" || settings.popup.content === "fromSlot") && popup.value) {
        settings.popup = {
          ...settings.popup,
          content: contentFunc
        };
      }
      return settings;
    });
    onMounted(async () => {
      if (!props.settings.coordinates) {
        throwException({
          text: "You must specify coordinates in YandexMapDefaultMarker settings"
        });
      }
      mapChildren = await setupMapChildren({
        createFunction: ({ YMapDefaultMarker: Marker }) => new Marker(getSettings.value),
        requiredImport: () => ymaps3.import("@yandex/ymaps3-markers@0.0.1"),
        settings: getSettings
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    watch(popup, () => {
      var _a;
      if (popup.value)
        (_a = popup.value.parentNode) == null ? void 0 : _a.removeChild(popup.value);
    });
    return () => {
      var _a;
      if (slots.popup) {
        return hF([
          h("div", {
            ref: popup
          }, (_a = slots.popup) == null ? void 0 : _a.call(slots, { close: closeFunc.value }))
        ]);
      }
      return void 0;
    };
  }
});
var _sfc_main$e = defineComponent({
  name: "YandexMapFeature",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      required: true
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    let mapChildren;
    onMounted(async () => {
      if (!props.settings.geometry) {
        throwException({
          text: "You must specify geometry in YandexMapFeature settings"
        });
      }
      mapChildren = await setupMapChildren({
        createFunction: () => new ymaps3.YMapFeature(props.settings),
        settings: computed(() => props.settings)
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    return () => {
      var _a;
      return hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
var _sfc_main$d = defineComponent({
  name: "YandexMapControls",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      required: true
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const mapChildren = shallowRef(null);
    onMounted(async () => {
      if (!props.settings.position) {
        throwException({
          text: "You must specify position in YandexMapControls settings"
        });
      }
      mapChildren.value = await setupMapChildren({
        createFunction: () => new ymaps3.YMapControls(props.settings),
        isMapRoot: true,
        settings: computed(() => props.settings)
      });
      emit("input", mapChildren.value);
      emit("update:modelValue", mapChildren.value);
    });
    return () => {
      var _a;
      return mapChildren.value ? hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {})) : h("div");
    };
  }
});
var _sfc_main$c = defineComponent({
  name: "YandexMapControl",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit,
    attrs
  }) {
    let mapChildren;
    const element = ref(null);
    onMounted(async () => {
      mapChildren = await setupMapChildren({
        createFunction: () => {
          const control = new ymaps3.YMapControl(props.settings);
          class YMapSomeController extends ymaps3.YMapEntity {
            _onAttach() {
              this._element = element.value;
              this._detachDom = ymaps3.useDomContext(this, this._element);
            }
            _onDetach() {
              this._detachDom();
              this._detachDom = null;
              this._element = null;
            }
          }
          control.addChild(new YMapSomeController({}));
          return control;
        },
        settings: computed(() => props.settings),
        strictMapRoot: true
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    return () => {
      var _a;
      return hF([
        h("div", {
          ref: element,
          ...getAttrsForVueVersion(attrs)
        }, (_a = slots.default) == null ? void 0 : _a.call(slots, {}))
      ]);
    };
  }
});
var _sfc_main$b = defineComponent({
  name: "YandexMapControlButton",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit,
    attrs
  }) {
    let mapChildren;
    const element = ref(null);
    onMounted(async () => {
      mapChildren = await setupMapChildren({
        createFunction: () => new ymaps3.YMapControlButton({
          ...props.settings,
          element: element.value
        }),
        settings: computed(() => ({
          ...props.settings,
          element: element.value
        })),
        strictMapRoot: true
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    return () => {
      var _a;
      return hF([
        h("div", {
          ref: element,
          ...getAttrsForVueVersion(attrs)
        }, (_a = slots.default) == null ? void 0 : _a.call(slots, {}))
      ]);
    };
  }
});
var _sfc_main$a = defineComponent({
  name: "YandexMapGeolocationControl",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    let mapChildren;
    onMounted(async () => {
      mapChildren = await setupMapChildren({
        createFunction: (controls) => new controls.YMapGeolocationControl(props.settings),
        requiredImport: () => ymaps3.import("@yandex/ymaps3-controls@0.0.1"),
        settings: computed(() => props.settings),
        strictMapRoot: true
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    return () => {
      var _a;
      return hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
var _sfc_main$9 = defineComponent({
  name: "YandexMapZoomControl",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  slots: Object,
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  setup(props, {
    slots,
    emit
  }) {
    let mapChildren;
    onMounted(async () => {
      mapChildren = await setupMapChildren({
        createFunction: (controls) => new controls.YMapZoomControl(props.settings),
        requiredImport: () => ymaps3.import("@yandex/ymaps3-controls@0.0.1"),
        settings: computed(() => props.settings),
        strictMapRoot: true
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    return () => {
      var _a;
      return hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
var _sfc_main$8 = defineComponent({
  name: "YandexMapScaleControl",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  slots: Object,
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  setup(props, {
    slots,
    emit
  }) {
    let mapChildren;
    onMounted(async () => {
      mapChildren = await setupMapChildren({
        createFunction: () => new ymaps3.YMapScaleControl(props.settings),
        settings: computed(() => props.settings),
        strictMapRoot: true
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    return () => {
      var _a;
      return hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
var _sfc_main$7 = defineComponent({
  name: "YandexMapCartesianProjection",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    bounds: {
      type: Array,
      required: true
    },
    cycled: {
      type: Array
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    },
    hold(status) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const hold = inject("needsToHold");
    hold.value++;
    const projection = inject("projection");
    onMounted(async () => {
      if (!projection)
        return;
      const cartesian = await setupMapChildren({
        isMercator: true,
        createFunction: ({ Cartesian: CartesianClass }) => new CartesianClass(props.bounds, props.cycled),
        requiredImport: () => ymaps3.import("@yandex/ymaps3-cartesian-projection@0.0.1")
      });
      projection.value = cartesian;
      emit("input", cartesian);
      emit("update:modelValue", cartesian);
      hold.value--;
    });
    return () => {
      var _a;
      return hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
var _sfc_main$6 = defineComponent({
  name: "YandexMapSphericalMercatorProjection",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    },
    hold(status) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const hold = inject("needsToHold");
    hold.value++;
    const projection = inject("projection");
    onMounted(async () => {
      if (!projection) {
        hold.value--;
        return;
      }
      const mercator = await setupMapChildren({
        isMercator: true,
        createFunction: ({ SphericalMercator: Mercator }) => new Mercator(),
        requiredImport: () => ymaps3.import("@yandex/ymaps3-spherical-mercator-projection@0.0.1")
      });
      projection.value = mercator;
      emit("input", mercator);
      emit("update:modelValue", mercator);
      hold.value--;
    });
    return () => {
      var _a;
      return hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
var _sfc_main$5 = defineComponent({
  name: "YandexMapHint",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    // Property that you will set on YandexMapMarker or YandexMapFeature to display hint content
    hintProperty: {
      type: String,
      required: true
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit,
    attrs
  }) {
    let mapChildren;
    const element = shallowRef(null);
    const hintContent = shallowRef("");
    onMounted(async () => {
      await setupMapChildren({
        createFunction: ({
          YMapHint: MapHint,
          YMapHintContext
        }) => {
          mapChildren = new MapHint({
            hint: (object) => {
              var _a;
              return (_a = object == null ? void 0 : object.properties) == null ? void 0 : _a[props.hintProperty];
            }
          });
          class Hint extends ymaps3.YMapEntity {
            _onAttach() {
              const e = this;
              e._element = element.value;
              e._detachDom = ymaps3.useDomContext(e, e._element, null);
              e._watchContext(YMapHintContext, () => {
                var _a;
                hintContent.value = (_a = e._consumeContext(YMapHintContext)) == null ? void 0 : _a[props.hintProperty];
              }, { immediate: true });
            }
            _onDetach() {
              this._detachDom();
            }
          }
          mapChildren.addChild(new Hint({}));
          return mapChildren;
        },
        requiredImport: () => ymaps3.import("@yandex/ymaps3-hint@0.0.1")
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    return () => {
      var _a;
      return hF([
        h("div", {
          ref: element,
          ...getAttrsForVueVersion(attrs)
        }, (_a = slots.default) == null ? void 0 : _a.call(slots, { content: hintContent.value }))
      ]);
    };
  }
});
var _sfc_main$4 = defineComponent({
  name: "YandexMapOpenMapsButton",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    let mapChildren;
    onMounted(async () => {
      mapChildren = await setupMapChildren({
        createFunction: ({ YMapOpenMapsButton: OpenMapsButton }) => new OpenMapsButton(props.settings),
        requiredImport: () => ymaps3.import("@yandex/ymaps3-controls-extra"),
        settings: computed(() => props.settings),
        strictMapRoot: true
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    return () => {
      var _a;
      return hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
var _sfc_main$3 = defineComponent({
  name: "YandexMapClustererClusters",
  props: {
    clusterMarkerProps: {
      type: Object,
      default: () => ({})
    },
    zoomOnClusterClick: {
      type: [Boolean, Object],
      default: false
    }
  },
  slots: Object,
  emits: {
    // Exact features bounds returned on cluster click
    trueBounds(bounds) {
      return bounds.length === 2;
    },
    // Auto-corrected features bounds returned on cluster click
    updatedBounds(bounds) {
      return bounds.length === 2;
    }
  },
  setup(props, { slots, emit }) {
    const map = injectMap();
    const features = inject("clusterFeatures");
    const containerProps = computed(() => {
      var _a, _b, _c, _d;
      return getMarkerContainerProps({
        position: ((_a = props.clusterMarkerProps) == null ? void 0 : _a.position) ?? "top-center left-center",
        containerAttrs: (_b = props.clusterMarkerProps) == null ? void 0 : _b.containerAttrs,
        wrapperAttrs: (_c = props.clusterMarkerProps) == null ? void 0 : _c.wrapperAttrs,
        zeroSizes: (_d = props.clusterMarkerProps) == null ? void 0 : _d.zeroSizes
      });
    });
    return () => {
      const clusterSlots = features.value.map(({
        clusterer,
        element
      }, index) => {
        var _a;
        return hF([
          h(
            "div",
            {
              ...containerProps.value.root,
              ref: async (_item) => {
                if (!_item)
                  return;
                const item = _item;
                if (element.children.length)
                  return;
                await nextTick();
                try {
                  element.addChild(new ymaps3.YMapMarker({
                    ...excludeYandexMarkerProps(props.clusterMarkerProps),
                    coordinates: clusterer.lnglat,
                    onClick: async (e) => {
                      var _a2, _b, _c, _d;
                      (_b = (_a2 = props.clusterMarkerProps).onClick) == null ? void 0 : _b.call(_a2, e);
                      if (clusterer.features.length >= 2) {
                        const settings = typeof props.zoomOnClusterClick === "object" ? props.zoomOnClusterClick : {};
                        const featuresCoords = clusterer.features.map((x) => x.geometry.coordinates);
                        const bounds = getBoundsFromCoords(featuresCoords);
                        emit("trueBounds", bounds);
                        if (!props.zoomOnClusterClick)
                          return;
                        const defaultDuration = settings.duration ?? 500;
                        if (settings.strategy === "boundsCorrect") {
                          const [[minLongitude, maxLatitude], [maxLongitude, minLatitude]] = bounds;
                          const latDiff = maxLatitude - minLatitude;
                          const longDiff = maxLongitude - minLongitude;
                          const updatedBounds = [[minLongitude - longDiff, maxLatitude - latDiff], [maxLongitude + longDiff, minLatitude + latDiff]];
                          emit("updatedBounds", updatedBounds);
                          (_c = map.value) == null ? void 0 : _c.setLocation({
                            bounds: updatedBounds,
                            duration: defaultDuration,
                            easing: settings.easing
                          });
                        } else {
                          const { center, zoom } = await getLocationFromBounds({
                            bounds,
                            map: map.value,
                            roundZoom: true,
                            comfortZoomLevel: true
                          });
                          (_d = map.value) == null ? void 0 : _d.setLocation({
                            center,
                            zoom,
                            duration: defaultDuration,
                            easing: settings.easing
                          });
                          await sleep(defaultDuration + 50);
                          if (map.value)
                            emit("updatedBounds", map.value.bounds);
                        }
                      }
                    }
                  }, item));
                } catch (e) {
                  console.error(e);
                }
              }
            },
            [
              h("div", {
                ...containerProps.value.children
              }, (_a = slots.default) == null ? void 0 : _a.call(slots, {
                clusterer,
                coordinates: clusterer.lnglat,
                length: clusterer.features.length
              }))
            ]
          )
        ], {
          key: clusterer.clusterId + clusterer.features.length
        });
      });
      return hF(clusterSlots);
    };
  }
});
var _sfc_main$2 = defineComponent({
  name: "YandexMapClusterer",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    },
    /**
     * @description All custom (non-settings) props are also supported
     */
    clusterMarkerProps: {
      type: Object,
      default: () => ({})
    },
    /**
     * @description Size of the grid division in pixels
     *
     * Used in settings.method via Yandex clusterByGrid method
     *
     * @see https://yandex.ru/dev/jsapi30/doc/ru/ref/packages/clusterer/
     * @see https://yandex.ru/dev/jsapi30/doc/en/ref/packages/clusterer/
     */
    gridSize: {
      type: Number,
      default: 64
    },
    /**
     * @description Zooms to bounds of features of cluster
     */
    zoomOnClusterClick: {
      type: [Boolean, Object],
      default: false
    }
  },
  slots: Object,
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    },
    // Exact features bounds returned on cluster click
    trueBounds(bounds) {
      return bounds.length === 2;
    },
    // Auto-corrected features bounds returned on cluster click
    updatedBounds(bounds) {
      return bounds.length === 2;
    }
  },
  setup(props, {
    slots,
    emit
  }) {
    const mapChildren = shallowRef(null);
    const entities = shallowRef([]);
    const clusterFeatures = shallowRef([]);
    const filteredFeatures = computed(() => clusterFeatures.value.filter((x) => x.clusterer.features.length > 1));
    provide("clusterFeatures", filteredFeatures);
    let _clusterByGrid;
    const tickTimeout = computed(() => props.settings.tickTimeout);
    const getSettings = () => {
      const settings = { ...props.settings };
      if (!settings.method && _clusterByGrid)
        settings.method = _clusterByGrid == null ? void 0 : _clusterByGrid({ gridSize: props.gridSize });
      if (tickTimeout.value)
        settings.tickTimeout = tickTimeout.value;
      const marker = (feature) => {
        const entity = entities.value.find((x) => x._props.id === feature.id);
        if (!entity) {
          throwException({
            text: `No entity with id ${feature.id} (coordinates: ${feature.geometry.coordinates.join(", ")}) were found in YandexMapClusterer.`,
            isInternal: true,
            warn: true
          });
          return new ymaps3.YMapMarker({ coordinates: feature.geometry.coordinates });
        }
        return entity;
      };
      const cluster = (coordinates) => {
        const foundCluster = clusterFeatures.value.find((x) => x.clusterer.lnglat[0] === coordinates[0] && x.clusterer.lnglat[1] === coordinates[1]);
        if (!foundCluster) {
          throwException({
            text: `No element with coordinates of ${coordinates.join(", ")} were found in YandexMapClusterer.`,
            isInternal: true,
            warn: true
          });
          return new ymaps3.YMapMarker({ coordinates });
        }
        return foundCluster.element;
      };
      const features = entities.value.map((entity, i) => {
        if (!entity._props.id) {
          entity.update({
            id: Math.random().toString() + Date.now().toString()
          });
        }
        return {
          type: "Feature",
          id: entity._props.id,
          geometry: {
            type: "Point",
            coordinates: entity._props.coordinates
          },
          properties: "properties" in entity._props ? entity._props.properties : {}
        };
      });
      settings.onRender = (clustersList) => {
        clusterFeatures.value = clustersList.map((clusterer) => {
          var _a;
          return {
            clusterer,
            element: ((_a = clusterFeatures.value.find((x) => x.clusterer.clusterId === clusterer.clusterId)) == null ? void 0 : _a.element) || new ymaps3.YMapCollection({})
          };
        });
        if (props.settings.onRender)
          return props.settings.onRender(clustersList);
      };
      return {
        ...settings,
        marker,
        features,
        cluster
      };
    };
    const update = async () => {
      var _a, _b;
      await nextTick();
      (_a = mapChildren.value) == null ? void 0 : _a.update(getSettings());
      (_b = mapChildren.value) == null ? void 0 : _b._render();
    };
    watch(() => [props.settings, props.gridSize], () => {
      update();
    }, {
      deep: true
    });
    const init = async () => {
      mapChildren.value = await setupMapChildren({
        createFunction: ({
          YMapClusterer: Clusterer,
          clusterByGrid: _clusterByGrid_
        }) => {
          _clusterByGrid = _clusterByGrid_;
          return new Clusterer(getSettings());
        },
        requiredImport: () => ymaps3.import("@yandex/ymaps3-clusterer@0.0.1"),
        isMapRoot: true,
        mapRootRef: entities
      });
      emit("input", mapChildren.value);
      emit("update:modelValue", mapChildren.value);
    };
    watch(entities, async () => {
      await nextTick();
      update();
    });
    onMounted(() => {
      init();
    });
    return () => {
      var _a, _b;
      if (!mapChildren.value)
        return h("div");
      if (isVue2()) {
        return h("div", [
          ...((_a = slots.default) == null ? void 0 : _a.call(slots, {})) || [],
          h(_sfc_main$3, {
            props: {
              clusterMarkerProps: props.clusterMarkerProps,
              zoomOnClusterClick: props.zoomOnClusterClick
            },
            on: {
              trueBounds: (e) => emit("trueBounds", e),
              updatedBounds: (e) => emit("updatedBounds", e)
            },
            scopedSlots: {
              default: (options) => {
                var _a2;
                return h("div", {}, [(_a2 = slots.cluster) == null ? void 0 : _a2.call(slots, options)]);
              }
            }
          })
        ]);
      }
      return h("div", [
        ...((_b = slots.default) == null ? void 0 : _b.call(slots, {})) || [],
        h(_sfc_main$3, {
          clusterMarkerProps: props.clusterMarkerProps,
          zoomOnClusterClick: props.zoomOnClusterClick,
          onTrueBounds: (e) => emit("trueBounds", e),
          onUpdatedBounds: (e) => emit("updatedBounds", e)
        }, {
          default: (options) => {
            var _a2;
            return (_a2 = slots.cluster) == null ? void 0 : _a2.call(slots, options);
          }
        })
      ]);
    };
  }
});
var _sfc_main$1 = defineComponent({
  name: "YandexMapCollection",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const mapChildren = shallowRef(null);
    onMounted(async () => {
      mapChildren.value = await setupMapChildren({
        createFunction: () => new ymaps3.YMapCollection({}),
        isMapRoot: true
      });
      emit("input", mapChildren.value);
      emit("update:modelValue", mapChildren.value);
    });
    return () => {
      if (!mapChildren.value)
        return h("div");
      return () => {
        var _a;
        return hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {}));
      };
    };
  }
});
var _sfc_main = defineComponent({
  name: "YandexMapEntity",
  inheritAttrs: false,
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit,
    attrs
  }) {
    let mapChildren;
    const element = ref(null);
    onMounted(async () => {
      mapChildren = await setupMapChildren({
        createFunction: () => {
          class Entity extends ymaps3.YMapEntity {
            _onAttach() {
              this._element = element.value;
              this._detachDom = ymaps3.useDomContext(this, this._element);
            }
            _onDetach() {
              this._detachDom();
              this._detachDom = null;
              this._element = null;
            }
          }
          return new Entity({});
        }
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    return () => {
      var _a;
      return hF([
        h("div", {
          ref: element,
          ...getAttrsForVueVersion(attrs)
        }, (_a = slots.default) == null ? void 0 : _a.call(slots, {}))
      ]);
    };
  }
});
export {
  VueYandexMaps,
  _sfc_main$o as YandexMap,
  _sfc_main$7 as YandexMapCartesianProjection,
  _sfc_main$2 as YandexMapClusterer,
  _sfc_main$1 as YandexMapCollection,
  _sfc_main$c as YandexMapControl,
  _sfc_main$b as YandexMapControlButton,
  _sfc_main$d as YandexMapControls,
  _sfc_main$m as YandexMapDefaultFeaturesLayer,
  _sfc_main$f as YandexMapDefaultMarker,
  _sfc_main$k as YandexMapDefaultSatelliteLayer,
  _sfc_main$l as YandexMapDefaultSchemeLayer,
  _sfc_main as YandexMapEntity,
  _sfc_main$e as YandexMapFeature,
  _sfc_main$i as YandexMapFeatureDataSource,
  _sfc_main$a as YandexMapGeolocationControl,
  _sfc_main$5 as YandexMapHint,
  _sfc_main$h as YandexMapLayer,
  _sfc_main$n as YandexMapListener,
  _sfc_main$g as YandexMapMarker,
  _sfc_main$4 as YandexMapOpenMapsButton,
  _sfc_main$8 as YandexMapScaleControl,
  _sfc_main$6 as YandexMapSphericalMercatorProjection,
  _sfc_main$j as YandexMapTileDataSource,
  _sfc_main$9 as YandexMapZoomControl,
  createYmaps,
  createYmapsOptions,
  createYmapsVue2,
  getBoundsFromCoords,
  getCenterFromCoords,
  getLocationFromBounds,
  initYmaps,
  useYMapsLocationFromBounds
};
//# sourceMappingURL=vue-yandex-maps.js.map
